#set text(font: "New Computer Modern", lang: "el")

#set page(
  paper: "a4",
  margin: (top: 2.5cm, bottom: 2.5cm, left: 2.5cm, right: 2.5cm),
)

#set heading(numbering: "1.")


#show heading: it => {
  set text(weight: "bold")
  v(1em)
  line(length: 100%)
  align(left)[#it.body]
  v(0.5em)
}




#align(center)[#text(22pt)[Παραδοτέο 1]]

#align(center)[#text(16pt)[Μάθημα: Ανάπτυξη Λογισμικού για Πληροφοριακά Συστήματα]]

#v(3em)
#align(center)[#text(14pt)[Μέλη Ομάδας:]]
#align(center)[#text(12pt)[Ραμαντάν Κονόμι - ΑΜ: 1115201800281]]
#align(center)[#text(12pt)[Θεμιστοκλής Παπαθεοφάνους - ΑΜ: 1115202100227]]
#align(center)[#text(12pt)[Μάριος Γιαννόπουλος - ΑΜ: 1115202000032]]

#outline(
  title: "Πίνακας Περιεχομένων",
  depth: 2,
  indent: auto,
)
#pagebreak()


#align(center)[#text(12pt)[Ανάλυση της Κλάσης #text(weight: "bold")[HopscotchTable]]]
= HopscotchTable <hopscotch>
= Δομές Δεδομένων <hopscotch_data_structures>
#align(center)[#text(12pt)[Ανάλυση της Κλάσης #text(weight: "bold")[RobinHoodTable]]]
= RobinHoodTable <robinhood>
#align(center)[#text(12pt)[Ανάλυση της Κλάσης #text(weight: "bold")[CuckooTable]]]
= CuckooTable <cuckoo>
= Δομές Δεδομένων <cuckoo_data_structures>

Η κλάση `CuckooTable<Key>` υλοποιεί τον αλγόριθμο Κατακερματισμού Cuckoo (Cuckoo Hashing), μια προηγμένη τεχνική κατακερματισμού που εγγυάται σταθερό χρόνο αναζήτησης `O(1)` στην *χειρότερη* περίπτωση. Σε αντίθεση με τις μεθόδους ανοικτής διευθυνσιοδότησης που βασίζονται σε chaining ή γραμμική διερεύνηση (linear probing), το Cuckoo Hashing χρησιμοποιεί πολλαπλούς πίνακες και συναρτήσεις κατακερματισμού για να εξασφαλίσει ότι κάθε στοιχείο βρίσκεται ακριβώς σε μία από τις λίγες πιθανές θέσεις του.

= Δομές Δεδομένων

Ο πίνακας Cuckoo αποτελείται από δύο πίνακες, `table_1` και `table_2`, ίσου `capacity`.

#heading(level: 2, "CuckooEntry")
Κάθε θέση στους πίνακες μπορεί να περιέχει ένα `CuckooEntry` ή να είναι κενή (\`std::nullopt\`). Η δομή `CuckooEntry` αποθηκεύει το κλειδί (`Key`) και έναν συσσωρευτή δεικτών (\`std::vector<size_t> indices\`), καθώς η υλοποίηση επιτρέπει σε πολλαπλές εγγραφές να κατακερματίζονται στο ίδιο κλειδί.

```cpp
struct CuckooEntry {
    Key key;
    std::vector<size_t> indices;
};
```

#heading(level: 2, "Πίνακες και Χωρητικότητα")
Ο πίνακας διαχειρίζεται δύο εσωτερικούς πίνακες `table_1` και `table_2`, καθένας με χωρητικότητα `capacity`.

```cpp
std::vector<std::optional<CuckooEntry<Key>>> table1;
std::vector<std::optional<CuckooEntry<Key>>> table2;
size_t capacity;
```

= Συναρτήσεις Κατακερματισμού

Χρησιμοποιούνται δύο ανεξάρτητες συναρτήσεις κατακερματισμού, `h_1` και `h_2`, για την αντιστοίχιση ενός κλειδιού σε μια θέση στους `table_1` και `table_2` αντίστοιχα.

#heading(level: 2, "Συνάρτηση `h_1`")
Η `h_1` είναι η τυπική συνάρτηση κατακερματισμού, χρησιμοποιώντας την `std::hash<Key>`.

```cpp
    size_t h1(const Key& key) const {
    return key_hasher(key) % capacity;
}
```

#heading(level: 2, "Συνάρτηση `h_2`")
Η `h_2` προκύπτει από μια απλή κυκλική μετατόπιση (rotation) του αρχικού hash value, εξασφαλίζοντας μια δεύτερη, ανεξάρτητη διεύθυνση.

```cpp
    size_t h2(const Key& key) const {
    size_t h = key_hasher(key);
    // Κυκλική μετατόπιση αριστερά (e.g., κατά 1 bit)
    return ((h << 1) | (h >> (sizeof(size_t) * 8 - 1))) % capacity;
}
```

= Μηχανισμός Εισαγωγής (The Kick Process)

Η εισαγωγή ενός νέου στοιχείου γίνεται μέσω της διαδικασίας "εκτόπισης" (kicking) που υλοποιείται στη μέθοδο `insert_internal`.

#heading(level: 2, "Βήματα Εισαγωγής")
Η διαδικασία εισαγωγής ακολουθεί τους εξής κανόνες:
1. #text(weight: "bold")[Έλεγχος:] Το νέο στοιχείο ελέγχεται αρχικά στη θέση `h_1` του `table_1`.
2. #text(weight: "bold")[Εκτόπιση (Kick):] Εάν η θέση `h_1` είναι κατειλημμένη, το υπάρχον στοιχείο εκτοπίζεται (διώχνεται). Το εκτοπισμένο στοιχείο αναζητά στη συνέχεια τη δική του εναλλακτική θέση.
3. #text(weight: "bold")[Εναλλακτική Θέση:] Το εκτοπισμένο στοιχείο προσπαθεί να εισαχθεί στη θέση `h_2` του `table_2`.
4. #text(weight: "bold")[Επανάληψη:] Εάν και η θέση `h_2` είναι κατειλημμένη, το στοιχείο που βρισκόταν εκεί εκτοπίζεται και η διαδικασία επιστρέφει στον `table_1` για το εκτοπισμένο στοιχείο (χρησιμοποιώντας τη δική του συνάρτηση `h_1`).

Η διαδικασία αυτή συνεχίζεται έως ότου βρεθεί μια κενή θέση.

#heading(level: 2, "Όριο Εκτοπίσεων (MAX_KICKS)")
Για να αποφευχθεί ο ατέρμονος βρόχος (cycle) που μπορεί να προκληθεί από την κυκλική εκτόπιση στοιχείων, η υλοποίηση θέτει ένα όριο `MAX_KICKS` (σταθερά `500`). Αν το όριο αυτό ξεπεραστεί, θεωρείται ότι έχει εντοπιστεί ένας κύκλος και απαιτείται ανακατακερματισμός.

= Ανακατακερματισμός (Rehash)

#heading(level: 2, "Συνθήκη Ανακατακερματισμού")
Ο ανακατακερματισμός ενεργοποιείται όταν η εισαγωγή ενός στοιχείου αποτύχει να βρει μια κενή θέση εντός του ορίου `MAX_KICKS`.

#heading(level: 2, "Διαδικασία")
Η μέθοδος `rehash()` εκτελεί τα εξής:
1. #text(weight: "bold")[Διπλασιασμός Χωρητικότητας:] Ο `capacity` διπλασιάζεται (`capacity` $arrow.r$ `2` $times$ `capacity`).
2. #text(weight: "bold")[Επαναφορά Πινάκων:] Δημιουργούνται νέοι, κενοί πίνακες `table_1` και `table_2` με τη νέα χωρητικότητα.
3. #text(weight: "bold")[Επανεισαγωγή:] Όλα τα στοιχεία από τους παλιούς πίνακες μετακινούνται και επανεισάγονται στους νέους πίνακες.

= Αναζήτηση (Search)

Η αναζήτηση (`search`) είναι η απλούστερη λειτουργία του Cuckoo Hashing, καθώς το στοιχείο μπορεί να βρίσκεται μόνο σε δύο πιθανές θέσεις:

1. Στη θέση `h_1(key)` του `table_1`.
2. Στη θέση `h_2(key)` του `table_2`.

Η `search` απλά ελέγχει αυτές τις δύο θέσεις. Αν το κλειδί βρεθεί σε οποιονδήποτε από τους δύο πίνακες, επιστρέφεται ένας δείκτης (`std::optional<std::vector<size_t>*>`) στη συλλογή δεικτών του. Αυτό εγγυάται `O(1)` χρόνο αναζήτησης στην χειρότερη περίπτωση.

#v(1em)
#line(length: 100%)