#set text(font: "New Computer Modern", lang: "el")


#set page(
  paper: "a4",
  margin: (top: 2.5cm, bottom: 2.5cm, left: 2.5cm, right: 2.5cm),
)

#set heading(numbering: "1.")


#show heading: it => {
  set text(weight: "bold")
  v(1em)
  // line(length: 100%)
  align(left)[#it.body]
  v(0.35em)
}

#align(center)[#text(22pt)[Παραδοτέο 1]]

#align(center)[#text(16pt)[Μάθημα: Ανάπτυξη Λογισμικού για Πληροφοριακά Συστήματα]]

#v(3em)
#align(center)[#text(14pt)[Μέλη Ομάδας:]]
#align(center)[#text(12pt)[Ραμαντάν Κονόμι - ΑΜ: 1115201800281]]
#align(center)[#text(12pt)[Θεμιστοκλής Παπαθεοφάνους - ΑΜ: 1115202100227]]
#align(center)[#text(12pt)[Μάριος Γιαννόπουλος - ΑΜ: 1115202000032]]

#outline(
  title: "Πίνακας Περιεχομένων",
  depth: 2,
  indent: auto,
)
#pagebreak()


#align(center)[#text(12pt)[Ανάλυση της Κλάσης #text(weight: "bold")[HopscotchTable]]]
= HopscotchTable <hopscotch>
= Δομές Δεδομένων <hopscotch_data_structures>
= Συναρτήσεις Κατακερματισμού
#align(center)[#text(12pt)[Ανάλυση της Κλάσης #text(weight: "bold")[RobinHoodTable]]]
= RobinHoodTable <robinhood>
Η κλάση `RobinHoodTable` υλοποιεί τον Κατακερματισμό Robin Hood, μια στρατηγική επίλυσης συγκρούσεων ανοικτής διευθυνσιοδότησης που εμπνέεται από το ρητό "κλέβει από τους πλούσιους και δίνει στους φτωχούς". Ο κύριος στόχος της είναι η #text(weight: "bold")[ελαχιστοποίηση της διακύμανσης] των μηκών των αλυσίδων διερεύνησης (Probe Sequence Length - PSL) για όλα τα κλειδιά, βελτιώνοντας δραστικά τον χρόνο αναζήτησης στην #text(weight: "bold")[χειρότερη περίπτωση] και την απόδοση της κρυφής μνήμης (cache locality).
= Δομές Δεδομένων <robinhood_data_structures>
Κάθε καταχώρηση στον πίνακα αποθηκεύει, εκτός από το κλειδί, το Μήκος Ακολουθίας Διερεύνησης (PSL).
#heading(level: 2, "Probe Sequence Length (PSL)")
Το PSL μετρά την απόσταση του κλειδιού από την #text(weight: "bold")[ιδανική (primal) θέση] του, όπως αυτή ορίζεται από τη συνάρτηση κατακερματισμού.

```
PSL = (i - p) mod m
```

-   $i$: τρέχουσα θέση του κλειδιού.
-   $p$: ιδανική θέση (αρχικό hash index).
-   $m$: μέγεθος πίνακα.
- #text(weight: "bold")[PSL = 0]: Το κλειδί βρίσκεται στην ιδανική του θέση (χωρίς συγκρούσεις).
- #text(weight: "bold")[PSL = +1]: Το PSL αυξάνεται κατά 1 για κάθε σύγκρουση κατά την εισαγωγή.

= Συναρτήσεις Κατακερματισμού και Μεγέθη Πινάκων
#heading(level: 2, "Συνάρτηση Κατακερματισμού - Fibonacci Hashing")
Η υλοποίηση χρησιμοποιεί #text(weight: "bold")[πολλαπλασιαστικό κατακερματισμό] (multiplicative hashing) με σταθερές που βασίζονται στον χρυσό λόγο (Fibonacci Hashing) για κλειδιά τύπου `int32_t`. Η τεχνική αυτή χρησιμοποιεί δύο διαφορετικά "κομμάτια" του κατακερματισμού συνδυασμένα με bitwise OR για να επιτύχει:

- #text(weight: "bold")[Φαινόμενο Χιονοστιβάδας (Avalanche Effect)].
- Ομοιόμορφη κατανομή.
-  Μειωμένο clustering.

#heading(level: 2, "Μέγεθος Πίνακα και Συντελεστής Φόρτου")

- #text(weight: "bold")[Μέγεθος Πίνακα]: Είναι πάντα #text(weight: "bold")[δύναμη του δύο], το οποίο επιτρέπει τον γρήγορο υπολογισμό του δείκτη μέσω bitwise AND: `index = h(k) & (m - 1)`, αποφεύγοντας δαπανηρές πράξεις modulo.
- #text(weight: "bold")[Συντελεστής Φόρτου (Load Factor)]: Διατηρείται στο βέλτιστο επίπεδο του #text(weight: "bold")[≈ 60%] (με εύρος 60-75%) για να εξασφαλίσει χαμηλό μέσο και φραγμένο χειρότερο μήκος διερεύνησης.

= Στρατηγική Επίλυσης Συγκρούσεων (Εισαγωγή)
Ο αλγόριθμος βασίζεται στον κανόνα εκτόπισης: "Ο πλούσιος δίνει τη θέση του στον φτωχό".

#heading(level: 2, "Διαδικασία Εκτόπισης (The Swap)")

Όταν εισάγεται ένα νέο κλειδί με PSL $P#sub[new]$ σε μια θέση κατειλημμένη από κλειδί με PSL $P#sub[old]$:

- #text(weight: "bold")[Κανόνας Robin Hood:] Αν $P#sub[new] > P#sub[old]$, το εισερχόμενο κλειδί (#text(style: "italic")[ο "φτωχός"] - δηλαδή αυτό που βρίσκεται πιο μακριά από την ιδανική του θέση) εκτοπίζει το υπάρχον κλειδί (#text(style: "italic")[ο "πλούσιος"]).

- #text(weight: "bold")[Συνέχεια Διερεύνησης:] Το εκτοπισμένο κλειδί (το οποίο τώρα είναι "στον αέρα") συνεχίζει τη γραμμική διερεύνηση (linear probing) με το PSL του #text(weight: "bold")[αυξημένο κατά 1].
Η διαδικασία συνεχίζεται έως ότου βρεθεί μια κενή θέση.

= Βελτιστοποίηση Πρόωρου Τερματισμού (Αναζήτηση)
Η σημαντικότερη βελτιστοποίηση είναι ο #text(weight: "bold")[πρόωρος τερματισμός] κατά την αναζήτηση, ο οποίος εκμεταλλεύεται το Robin Hood invariant.

#heading(level: 2, "Συνθήκη Τερματισμού")
Κατά την αναζήτηση ενός κλειδιού, αν το τρέχον μήκος διερεύνησης (`vpsl`) υπερβεί το PSL (`table[p].psl`) του κλειδιού που βρίσκεται στην τρέχουσα θέση ($p$), η αναζήτηση #text(weight: "bold")[τερματίζεται άμεσα] με αποτέλεσμα "δεν βρέθηκε".

```cpp
if (vpsl > table[p].psl) break; // Key not found
```

= Χαρακτηριστικά Απόδοσης
#heading(level: 2, "Χρονική Πολυπλοκότητα")
-   #text(weight: "bold")[Μέση Περίπτωση:] $O(1)$ για εισαγωγή και αναζήτηση.
-   #text(weight: "bold")[Χειρότερη Περίπτωση:] $O(n)$, αλλά με πολύ μικρότερους σταθερούς παράγοντες σε σχέση με τη συνήθη γραμμική διερεύνηση (linear probing).
-   #text(weight: "bold")[Αναμενόμενο Μήκος Διερεύνησης:] $\u{2248} 2.5$ σε συντελεστή φόρτου 60%.

#heading(level: 2, "Γιατί Λειτουργεί")
Λόγω της στρατηγικής Robin Hood, κάθε κλειδί έχει εγγυημένα PSL μικρότερο ή ίσο με οποιοδήποτε κλειδί που βρίσκεται μπροστά του στην αλυσίδα διερεύνησης. Εάν το αναζητούμενο κλειδί υπήρχε, #text(weight: "bold")[θα είχε εκτοπίσει] το κλειδί με το μικρότερο PSL που συναντήθηκε. Επομένως, ο πρόωρος τερματισμός μειώνει το μήκος διερεύνησης κατά 50% ή περισσότερο σε αποτυχημένες αναζητήσεις.

#align(center)[#text(12pt)[Ανάλυση της Κλάσης #text(weight: "bold")[CuckooTable]]]
= CuckooTable <cuckoo>
Η κλάση `CuckooTable<Key>` υλοποιεί τον αλγόριθμο Κατακερματισμού Cuckoo (Cuckoo Hashing), μια προηγμένη τεχνική κατακερματισμού που εγγυάται σταθερό χρόνο αναζήτησης #text(weight: "bold")[$O(1)$] στην *χειρότερη* περίπτωση. Η υλοποίηση είναι βελτιστοποιημένη για αποδοτικότητα μνήμης και κρυφής μνήμης (Cache Efficiency), χρησιμοποιώντας έναν #text(weight: "bold")[μηχανισμό κοινόχρηστης αποθήκευσης] για πολλαπλές τιμές και #text(weight: "bold")[inline value optimization] για μοναδικές τιμές. Σε αντίθεση με τις μεθόδους ανοικτής διευθυνσιοδότησης που βασίζονται σε chaining ή γραμμική διερεύνηση (linear probing), το Cuckoo Hashing χρησιμοποιεί δύο πίνακες και δύο συναρτήσεις κατακερματισμού για να εξασφαλίσει ότι κάθε στοιχείο βρίσκεται ακριβώς σε μία από τις δύο πιθανές θέσεις του.

= Δομές Δεδομένων <cuckoo_data_structures>

Ο πίνακας Cuckoo αποτελείται από δύο πίνακες, `table1` και `table2`, ίσου `capacity`. Επιπλέον, χρησιμοποιεί κοινόχρηστη αποθήκευση για τις τιμές:

*   #text(weight: "bold")[`value_store`]: Αποθηκεύει τις τιμές (indices/items) που σχετίζονται με τα κλειδιά.
*   #text(weight: "bold")[`segments`]: Αποθηκεύει τους δείκτες για την πρόσβαση σε πολλαπλές τιμές εντός του `value_store`.

#heading(level: 2, "CuckooBucket")
Κάθε θέση στους πίνακες περιέχει ένα `CuckooBucket`, το οποίο αντικαθιστά την ανάγκη για `std::optional` μέσω του πεδίου `occupied`. Η δομή αυτή υποστηρίζει την inline βελτιστοποίηση:

```cpp
template<typename Key>
struct CuckooBucket {
    Key key;
    uint32_t first_segment; // Δείκτης για την αλυσίδα στοιχείων στο value_store (αν count > 1)
    uint32_t last_segment;  // Αποθηκεύει την τιμή (item) αν count = 1 (inline optimization)
    uint16_t count;         // Πλήθος τιμών
    bool occupied;          // Αντικαθιστά το std::optional
};
```

#heading(level: 2, "Πίνακες και Χωρητικότητα")
Ο πίνακας διαχειρίζεται δύο εσωτερικούς πίνακες table1 και table2, καθένας με χωρητικότητα capacity.
```cpp
std::vector<CuckooBucket<Key>> table1; // Χρήση CuckooBucket, όχι std::optional
std::vector<CuckooBucket<Key>> table2;
size_t capacity;
```

= Συναρτήσεις Κατακερματισμού

Χρησιμοποιούνται δύο ανεξάρτητες συναρτήσεις κατακερματισμού, h1 και h2, για την αντιστοίχιση ενός κλειδιού σε μια θέση στους table1 και table2 αντίστοιχα.

#heading(level: 2, "Συνάρτηση h1")
Η h1 είναι η τυπική συνάρτηση κατακερματισμού, χρησιμοποιώντας την std::hash<Key>.

```cpp
size_t h1(const Key& key) const {
    return key_hasher(key) % capacity;
}
```

#heading(level: 2, "Συνάρτηση h2")
Η h2 προκύπτει από μια απλή κυκλική μετατόπιση (rotation) του αρχικού hash value, εξασφαλίζοντας μια δεύτερη, ανεξάρτητη διεύθυνση.

```cpp
size_t h2(const Key& key) const {
    size_t h = key_hasher(key);
    // Κυκλική μετατόπιση αριστερά (e.g., κατά 1 bit)
    return ((h << 1) | (h >> (sizeof(size_t) * 8 - 1))) % capacity;
}
```

= Μηχανισμός Εισαγωγής (The Kick Process)

Η εισαγωγή ενός νέου στοιχείου γίνεται μέσω της διαδικασίας "εκτόπισης" (kicking) που υλοποιείται στη μέθοδο insert_internal.

#heading(level: 2, "Βήματα Εισαγωγής")
Η διαδικασία εισαγωγής ακολουθεί τους εξής κανόνες:
- #text(weight: "bold")[Έλεγχος Υπάρχοντος:] Πριν την εκτόπιση, ελέγχεται αν το κλειδί υπάρχει ήδη στις δύο πιθανές θέσεις του. Αν ναι, η νέα τιμή #text(weight: "bold")[απλώς προστίθεται] στο υπάρχον CuckooBucket (μέσω της insert_duplicate).
- #text(weight: "bold")[Ανταλλαγή/Εκτόπιση (Kick):] Εάν η θέση προορισμού είναι κατειλημμένη, το νέο στοιχείο εισάγεται και το υπάρχον στοιχείο εκτοπίζεται. Η ανταλλαγή πραγματοποιείται με την std::swap(bucket, table[idx]), όπου η μεταβλητή bucket περιέχει πάντα το στοιχείο που είναι "στον αέρα".
- #text(weight: "bold")[Μετάβαση:] Το εκτοπισμένο στοιχείο αναζητά την εναλλακτική του θέση στον άλλο πίνακα (από h1 σε h2 και αντίστροφα).
Η διαδικασία αυτή συνεχίζεται έως ότου βρεθεί μια κενή θέση.

#heading(level: 2, "Όριο Εκτοπίσεων (MAX_KICKS)")
Για να αποφευχθεί ο ατέρμονος βρόχος (cycle) που μπορεί να προκληθεί από την κυκλική εκτόπιση στοιχείων, η υλοποίηση θέτει ένα όριο MAX_KICKS (σταθερά 500). Αν το όριο αυτό ξεπεραστεί, θεωρείται ότι έχει εντοπιστεί ένας κύκλος και απαιτείται ανακατακερματισμός.

= Ανακατακερματισμός (Rehash)

#heading(level: 2, "Συνθήκη Ανακατακερματισμού")
Ο ανακατακερματισμός ενεργοποιείται όταν η εισαγωγή ενός στοιχείου αποτύχει να βρει μια κενή θέση εντός του ορίου MAX_KICKS.
#heading(level: 2, "Διαδικασία")
Η μέθοδος rehash() εκτελεί τα εξής:
- #text(weight: "bold")[Διπλασιασμός Χωρητικότητας:] Το capacity διπλασιάζεται.
- #text(weight: "bold")[Αποδοτική Μεταφορά Παλιών Πινάκων:] Οι παλιοί πίνακες μεταφέρονται με #text(weight: "bold")[`std::move`] σε τοπικές μεταβλητές, επιτυγχάνοντας $O(1)$ μεταφορά των πόρων (χωρίς αντιγραφή) πριν την εκκαθάριση των κύριων πινάκων.
- #text(weight: "bold")[Επαναφορά Πινάκων:] Δημιουργούνται νέοι, κενοί πίνακες table1 και table2 με τη νέα χωρητικότητα.
- #text(weight: "bold")[Επανεισαγωγή:] Όλα τα στοιχεία από τους παλιούς πίνακες επανεισάγονται στους νέους πίνακες.
= Αναζήτηση (Search)

Η αναζήτηση (find / search) είναι η απλούστερη λειτουργία του Cuckoo Hashing, καθώς το στοιχείο μπορεί να βρίσκεται μόνο σε δύο πιθανές θέσεις, εγγυώμενη #text(weight: "bold")[$O(1)$] χρόνο αναζήτησης στην χειρότερη περίπτωση:
Στη θέση h1(key) του table1.
Στη θέση h2(key) του table2.
Η συνάρτηση επιστρέφει ένα #text(weight: "bold")[`ValueSpan<Key>`]. Εάν βρεθεί το κλειδί:
Αν #text(weight: "bold")[`count == 1`] (Inline Optimization), η τιμή διαβάζεται απευθείας από το πεδίο `last_segment` του bucket.
Αν #text(weight: "bold")[`count > 1`], το span χρησιμοποιεί τους δείκτες `first_segment` και `segments` για να ανακτήσει την αλυσίδα τιμών από το κοινόχρηστο `value_store`.

#v(1em)
#line(length: 100%)